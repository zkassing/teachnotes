## git bash 的常用操作

#### 新增文件

`touch file`

#### 删除文件

`rm file`

#### 查看当前目录所有文件

`ls`

#### 查看文件内容

`cat file`

#### 复制文件

`cp old_file_name new_file_name`

#### 重命名文件

`mv old_file_name new_file_name`

#### 新建文件夹

`mkdir floder`

#### 删除空文件夹

`rmdir floder`

#### 删除非空文件夹

`rm -rf floder`

#### 进入文件夹

`cd floder`

#### 跳转到上级

`cd ../`

#### 清屏

`clear`(vscode `cls`)

#### 编辑文件

`vi filename`

按键`i`(insert) ===> 编辑

退出编辑模式: esc, 按键`:`, wq ==> 保存退出, q! ==> 不保存,退出



## 删除文件

在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件`test.txt`到 Git 并且提交：

![1546434230387](images/1546434230387.png)

一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了：

这个时候，Git 知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了：

![1546434261808](images/1546434261808.png)

现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：

![1546434301776](images/1546434301776.png)

现在，文件就从版本库中被删除了。

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

![1546434624272](images/1546434624272.png)

![1546434637107](images/1546434637107.png)

`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

### 小结

命令`git rm`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。

# 分支管理

分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了 Git 又学会了 SVN！

![learn-branches](images/0.png)

分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

比如就差最后一个分号的时候, 突然停电了... ![img](images/0550072C.jpg)

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

其他版本控制系统如 SVN 等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。

但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。

![1546436214345](images/1546436214345.png)

## 创建与合并分支

在[版本回退](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000)里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。

一开始的时候，`master`分支是一条线，Git 用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：

![git-br-initial](images/0-1546436268922.png)

每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长：

当我们创建新的分支，例如`dev`时，Git 新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上：

![git-br-create](images/0-1546436268940.png)

你看，Git 创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：

![git-br-dev-fd](images/0-1546436268960.png)

假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git 怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：

![git-br-ff-merge](images/0-1546436268970.png)

所以 Git 合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：

![git-br-rm](images/0-1546436268972.png)

下面开始实战。

首先，我们创建`dev`分支，然后切换到`dev`分支：

![1546436527538](images/1546436527538.png)

`git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：

然后，用`git branch`命令查看当前分支：

![1546436551060](images/1546436551060.png)

`git branch`命令会列出所有分支，当前分支前面会标一个`*`号。

然后，我们就可以在`dev`分支上正常提交，比如对 readme.txt 做个修改，加上一行：

![1546436580382](images/1546436580382.png)

然后提交：

![1546436610527](images/1546436610527.png)

现在，`dev`分支的工作完成，我们就可以切换回`master`分支：

![1546436639571](images/1546436639571.png)

切换回`master`分支后，再查看一个 readme.txt 文件，刚才添加的内容不见了！因为那个提交是在`dev`分支上，而`master`分支此刻的提交点并没有变：

![1546436658173](images/1546436658173.png)

![git-br-on-master](images/0-1546436269065.png)

现在，我们把`dev`分支的工作成果合并到`master`分支上：

![1546436686618](images/1546436686618.png)

`git merge`命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和`dev`分支的最新提交是完全一样的。

![1546436710210](images/1546436710210.png)

注意到上面的`Fast-forward`信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。

当然，也不是每次合并都能`Fast-forward`，我们后面会讲其他方式的合并。

合并完成后，就可以放心地删除`dev`分支了：

删除后，查看`branch`，就只剩下`master`分支了：

![1546436740558](images/1546436740558.png)

因为创建、合并和删除分支非常快，所以 Git 鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。

## 小结

Git 鼓励大量使用分支：

查看分支：`git branch`

创建分支：`git branch <name>`

切换分支：`git checkout <name>`

创建+切换分支：`git checkout -b <name>`

合并某分支到当前分支：`git merge <name>`

删除分支：`git branch -d <name>`

## 解决冲突

人生不如意之事十之八九，合并分支往往也不是一帆风顺的。

准备新的`feature1`分支，继续我们的新分支开发：

![1546437339163](images/1546437339163.png)

修改`readme.txt`最后一行，改为：

![1546437358798](images/1546437358798.png)

在`feature1`分支上提交：

![1546437396632](images/1546437396632.png)

切换到`master`分支：

![1546437436200](images/1546437436200.png)

Git 还会自动提示我们当前`master`分支比远程的`master`分支要超前 1 个提交。

在`master`分支上把`readme.txt`文件的最后一行改为：

![1546437454917](images/1546437454917.png)

提交：

![1546437491437](images/1546437491437.png)

现在，`master`分支和`feature1`分支各自都分别有新的提交，变成了这样：

![git-br-feature1](images/0-1546437301965.png)

这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：

![1546437550774](images/1546437550774.png)

果然冲突了！Git 告诉我们，`readme.txt`文件存在冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件：

![1546437571787](images/1546437571787.png)

我们可以直接查看 readme.txt 的内容：

![1546437595082](images/1546437595082.png)

Git 用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存(采用传入的修改)：

![1546437634012](images/1546437634012.png)

再提交：

![1546437676976](images/1546437676976.png)

现在，`master`分支和`feature1`分支变成了下图所示：

![git-br-conflict-merged](images/0-1546437302182.png)

用带参数的`git log`也可以看到分支的合并情况：

![1546437712807](images/1546437712807.png)

最后，删除`feature1`分支：

![1546437791808](images/1546437791808.png)

工作完成。

### 小结

当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。

用`git log --graph`命令可以看到分支合并图

## 分支管理策略

通常，合并分支时，如果可能，Git 会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。

如果要强制禁用`Fast forward`模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。

下面我们实战一下`--no-ff`方式的`git merge`：

首先，仍然创建并切换`dev`分支：

![1546438339787](images/1546438339787.png)

修改 readme.txt 文件，并提交一个新的 commit：

![1546438365196](images/1546438365196.png)

![1546438392347](images/1546438392347.png)

现在，我们切换回`master`：

![1546438422897](images/1546438422897.png)

准备合并`dev`分支，请注意`--no-ff`参数，表示禁用`Fast forward`：

![1546438454344](images/1546438454344.png)

因为本次合并要创建一个新的 commit，所以加上`-m`参数，把 commit 描述写进去。

合并后，我们用`git log`看看分支历史：



可以看到，不使用`Fast forward`模式，merge 后就像这样：

![git-no-ff-mode](images/0-1546438272087.png)

### 分支策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布 1.0 版本；

你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。

所以，团队合作的分支看起来就像这样：

![git-br-policy](images/0-1546438272067.png)

### 小结

Git 分支十分强大，在团队开发中应该充分应用。

合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。

## Bug 分支

软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

当你接到一个修复一个代号 101 的 bug 的任务时，很自然地，你想创建一个分支`issue-101`来修复它，但是，等等，当前正在`dev`上进行的工作还没有提交：

![1546438855168](images/1546438855168.png)

并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办？

幸好，Git 还提供了一个`stash`功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：

现在，用`git status`查看工作区，就是干净的（除非有没有被 Git 管理的文件），因此可以放心地创建分支来修复 bug。

![1546438892942](images/1546438892942.png)

首先确定要在哪个分支上修复 bug，假定需要在`master`分支上修复，就从`master`创建临时分支：

![1546438932443](images/1546438932443.png)

现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：

![1546438967929](images/1546438967929.png)

![1546439006802](images/1546439006802.png)

修复完成后，切换到`master`分支，并完成合并，最后删除`issue-101`分支：

![1546439054526](images/1546439054526.png)

太棒了，原计划两个小时的 bug 修复只花了 5 分钟！现在，是时候接着回到`dev`分支干活了！

![1546439085311](images/1546439085311.png)

工作区是干净的，刚才的工作现场存到哪去了？用`git stash list`命令看看：

![1546439110665](images/1546439110665.png)

工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：

一是用`git stash apply`恢复，但是恢复后，stash 内容并不删除，你需要用`git stash drop`来删除；

另一种方式是用`git stash pop`，恢复的同时把 stash 内容也删了：

![1546439149986](images/1546439149986.png)

再用`git stash list`查看，就看不到任何 stash 内容了：

![1546439213276](images/1546439213276.png)

你可以多次 stash，恢复的时候，先用`git stash list`查看，然后恢复指定的 stash，用命令：

![1546439380084](images/1546439380084.png)

![1546439414915](images/1546439414915.png)

![1546439365436](images/1546439365436.png)

### 小结

修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；

当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复 bug，修复后，再`git stash pop`，回到工作现场。

## Feature 分支

软件开发中，总有无穷无尽的新的功能要不断添加进来。

添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 feature 分支，在上面开发，完成后，合并，最后，删除该 feature 分支。

现在，你终于接到了一个新任务：开发代号为 Vulcan 的新功能，该功能计划用于下一代星际飞船。

于是准备开发：

5 分钟后，开发完毕：

![1546439771649](images/1546439771649.png)

`commit`之后，  切回`dev`，准备合并：

![1546439851148](images/1546439851148.png)

一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。

但是！

就在此时，接到上级命令，因经费不足，新功能必须取消！

虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：

![1546439883836](images/1546439883836.png)

销毁失败。Git 友情提醒，`feature-vulcan`分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的`-D`参数。。

现在我们强行删除：

![1546439906120](images/1546439906120.png)

终于删除成功！

### 小结

开发一个新 feature，最好新建一个分支；

如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。

# 标签管理

发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。

Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。

Git 有 commit，为什么还要引入 tag？

“请把上周一的那个版本打包发布，commit 号是 6a5819e...”

“一串乱七八糟的数字不好找！”

如果换一个办法：

“请把上周一的那个版本打包发布，版本号是 v1.2”

“好的，按照 tag v1.2 查找 commit 就行！”

所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。

## 创建标签

在 Git 中打标签非常简单，首先，切换到需要打标签的分支上：

然后，敲命令`git tag <name>`就可以打一个新标签：

可以用命令`git tag`查看所有标签：

![1546440387585](images/1546440387585.png)

默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？

方法是找到历史提交的 commit id，然后打上就可以了：

比方说要对`add merge`这次提交打标签，它对应的 commit id 是`f52c633`，敲入命令：

再用命令`git tag`查看标签：

![1546440452817](images/1546440452817.png)

注意，标签不是按时间顺序列出，而是按字母排序的。可以用`git show <tagname>`查看标签信息：

![1546440493352](images/1546440493352.png)

可以看到，`v0.9`确实打在`add merge`这次提交上。

还可以创建带有说明的标签，用`-a`指定标签名，`-m`指定说明文字：

用命令`git show <tagname>`可以看到说明文字：

![1546440554192](images/1546440554192.png)

注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。

### 小结

-   命令`git tag <tagname>`用于新建一个标签，默认为`HEAD`，也可以指定一个 commit id；
-   命令`git tag -a <tagname> -m "blablabla..."`可以指定标签信息；
-   命令`git tag`可以查看所有标签。



![1546440798083](images/1546440798083.png)

![1546440873568](images/1546440873568.png)
